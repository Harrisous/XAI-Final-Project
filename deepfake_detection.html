<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deepfake Image Detector Demo</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the overlay effect */
        .image-container {
            position: relative;
            display: inline-block;
            transition: transform 0.3s ease;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .image-container:hover {
            transform: translateY(-3px);
        }
        .gradcam-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Use multiply blend mode to simulate heatmap transparency */
            mix-blend-mode: multiply; 
            opacity: 0.7; 
            pointer-events: none;
        }
        .info-box {
            position: absolute;
            top: 0;
            right: 0;
            color: white;
            padding: 0.5rem 0.75rem;
            border-bottom-left-radius: 0.5rem;
            font-weight: 700;
            font-size: 0.875rem;
            z-index: 10;
        }
        /* Color classes */
        .risk-high { background-color: #ef4444; } /* Red */
        .risk-medium { background-color: #f97316; } /* Orange */
        .risk-low { background-color: #10b981; } /* Green */
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8 font-sans">

    <div class="max-w-7xl mx-auto">
        <header class="mb-8 p-6 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl font-extrabold text-gray-800">
                <span class="text-indigo-600">Deepfake</span> Image Detector Demo
            </h1>
            <p class="text-gray-500 mt-2">Upload images or provide URLs for batch detection simulation.</p>
        </header>

        <main>
            <!-- Input Section -->
            <section class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8 p-6 bg-white rounded-xl shadow-md">
                <div class="lg:col-span-1">
                    <label class="block text-sm font-medium text-gray-700 mb-2">1. Upload Local Images</label>
                    <input type="file" id="file-upload" accept="image/*" multiple 
                           class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 transition duration-150">
                </div>
                <div class="lg:col-span-2">
                    <label for="url-input" class="block text-sm font-medium text-gray-700 mb-2">2. Enter Web Image URLs (one per line)</label>
                    <textarea id="url-input" rows="3" 
                              class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                              placeholder="e.g., https://picsum.photos/400/300"></textarea>
                </div>
                <div class="lg:col-span-3 pt-4 border-t border-gray-200">
                    <button id="detect-button" 
                            class="w-full px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 transform hover:scale-[1.01]">
                        üöÄ Start Batch Detection
                    </button>
                </div>
            </section>

            <!-- Status and Results -->
            <section class="mb-8">
                <div id="status-message" class="p-4 rounded-lg text-sm hidden"></div>
            </section>

            <section>
                <h2 class="text-2xl font-semibold text-gray-700 mb-4 border-b pb-2">3. Detection Results</h2>
                <div id="results-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Results will be inserted here -->
                </div>
            </section>
        </main>
    </div>

    <script>
        const API_ENDPOINT = 'http://127.0.0.1:5000/detect_batch';
        const FILE_INPUT = document.getElementById('file-upload');
        const URL_INPUT = document.getElementById('url-input');
        const DETECT_BUTTON = document.getElementById('detect-button');
        const RESULTS_GRID = document.getElementById('results-grid');
        const STATUS_MESSAGE = document.getElementById('status-message');

        // --- Core Detection and Utility Functions ---

        function updateStatus(message, type = 'info') {
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.className = 'p-4 rounded-lg text-sm';
            STATUS_MESSAGE.classList.remove('hidden');

            // Apply Tailwind classes based on message type
            if (type === 'error') {
                STATUS_MESSAGE.classList.add('bg-red-100', 'text-red-700');
            } else if (type === 'success') {
                STATUS_MESSAGE.classList.add('bg-green-100', 'text-green-700');
            } else { // default info/warning
                STATUS_MESSAGE.classList.add('bg-blue-100', 'text-blue-700');
            }
        }

        /**
         * @description Converts a File or Blob object into a Base64 data URI.
         * @param {Blob|File} blob - The file or blob to read.
         * @returns {Promise<string>} - The data URI string.
         */
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        /**
         * @description Fetches an image from a URL and converts it to a Base64 URI.
         * @param {string} url - The URL of the image.
         * @returns {Promise<string>} - The Base64 data URI.
         */
        async function fetchUrlToBase64(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.statusText}`);
            }
            // Check content type to ensure it's an image
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.startsWith('image/')) {
                 throw new Error(`URL did not return an image. Content type: ${contentType}`);
            }

            const blob = await response.blob();
            return blobToBase64(blob);
        }

        /**
         * @description Renders the image with its overlay results into the DOM.
         * @param {string} imgBase64 - The image data URI.
         * @param {object} detectionResult - The results from the mock backend.
         * @param {string} source - The source name/URL.
         */
        function renderImageWithOverlay(imgBase64, detectionResult, source) {
            const confidence = detectionResult.confidence;
            const confidencePercent = (confidence * 100).toFixed(2);
            
            let riskLevel = '';
            let riskColor = '';
            let riskLabel = '';

            if (confidence >= 0.7) {
                riskLevel = 'risk-high';
                riskColor = '#ef4444';
                riskLabel = 'High Risk';
            } else if (confidence >= 0.4) {
                riskLevel = 'risk-medium';
                riskColor = '#f97316';
                riskLabel = 'Medium Risk';
            } else {
                riskLevel = 'risk-low';
                riskColor = '#10b981';
                riskLabel = 'Low Risk';
            }

            // The GradCAM image is returned directly as a Base64 URI from the backend.
            const gradcamUri = detectionResult.gradcamImage; 

            const resultHTML = `
                <div class="image-container w-full">
                    <!-- Original Image (Base64) -->
                    <img src="${imgBase64}" alt="Detected Image" class="w-full h-auto block">
                    
                    <!-- GradCAM Overlay -->
                    <img src="${gradcamUri}" alt="GradCAM Heatmap" class="gradcam-layer">
                    
                    <!-- Confidence Box -->
                    <div class="info-box ${riskLevel}">
                        Deepfake Rate: ${confidencePercent}%
                        <div class="font-normal text-xs">(${riskLabel})</div>
                    </div>
                </div>
                <p class="text-xs text-gray-500 text-center mt-2 truncate" title="${source}">
                    Source: ${source}
                </p>
            `;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'w-full';
            wrapper.innerHTML = resultHTML;

            RESULTS_GRID.appendChild(wrapper);
        }

        /**
         * @description Main function to start the detection process by sending a batch request to the backend.
         */
        async function processAllInputs() {
            RESULTS_GRID.innerHTML = '';
            DETECT_BUTTON.disabled = true;
            updateStatus('Gathering images and preparing for batch detection...', 'info');

            const files = Array.from(FILE_INPUT.files);
            const urls = URL_INPUT.value.split('\n').map(url => url.trim()).filter(url => url.length > 0);

            let totalCount = files.length + urls.length;
            if (totalCount === 0) {
                updateStatus('Please upload at least one image or provide a URL.', 'error');
                DETECT_BUTTON.disabled = false;
                return;
            }

            // 1. Prepare the batch payload
            const imagePayloads = [];
            let currentId = 0;

            // Process Local Files
            const localFilePromises = files.map(async (file) => {
                try {
                    const base64 = await blobToBase64(file);
                    imagePayloads.push({ id: file.name, base64Data: base64, originalBase64: base64 });
                } catch (e) {
                    console.error(`Error processing local file ${file.name}:`, e);
                    // Add error placeholder in results grid immediately
                    RESULTS_GRID.innerHTML += `<div class="w-full"><div class="p-4 bg-red-100 text-red-700 rounded-lg text-sm">Failed to prepare: ${file.name}</div></div>`;
                }
            });

            // Process URLs
            const urlPromises = urls.map(async (url) => {
                try {
                    const base64 = await fetchUrlToBase64(url);
                    imagePayloads.push({ id: url, base64Data: base64, originalBase64: base64 });
                } catch (e) {
                    console.error(`Error fetching/processing URL ${url}:`, e);
                    // Add error placeholder in results grid immediately
                    RESULTS_GRID.innerHTML += `<div class="w-full"><div class="p-4 bg-red-100 text-red-700 rounded-lg text-sm">Failed to load URL: ${url}</div></div>`;
                }
            });

            // Wait for all Base64 conversions before sending the batch request
            await Promise.all([...localFilePromises, ...urlPromises]);

            if (imagePayloads.length === 0) {
                 updateStatus('No valid images were prepared for detection.', 'error');
                 DETECT_BUTTON.disabled = false;
                 return;
            }

            updateStatus(`Sending batch request for ${imagePayloads.length} images to backend...`, 'info');

            // 2. Send Batch Request to Flask Backend
            try {
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ images: imagePayloads.map(p => ({ id: p.id, base64Data: p.base64Data })) })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                // 3. Process Results
                let successfulCount = 0;
                
                data.results.forEach(result => {
                    const originalPayload = imagePayloads.find(p => p.id === result.id);
                    if (result.status === 'success' && originalPayload) {
                        // The backend returns confidence and gradcamImage URI
                        renderImageWithOverlay(originalPayload.originalBase64, result, result.id);
                        successfulCount++;
                    } else {
                        // Handle detection failure reported by the backend
                        RESULTS_GRID.innerHTML += `<div class="w-full"><div class="p-4 bg-yellow-100 text-yellow-700 rounded-lg text-sm">Detection failed for ${result.id}.</div></div>`;
                    }
                });
                
                updateStatus(`üéâ Detection completed for ${successfulCount} images.`, 'success');

            } catch (e) {
                console.error('Backend Communication Error:', e);
                updateStatus(`‚ùå Could not connect to backend or API error: ${e.message}. Ensure app.py is running.`, 'error');
            } finally {
                DETECT_BUTTON.disabled = false;
            }
        }

        // --- Event Listener ---
        DETECT_BUTTON.addEventListener('click', processAllInputs);
    </script>
</body>
</html>